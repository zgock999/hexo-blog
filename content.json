{"pages":[{"title":"About","text":"お前誰よ？mstdn.maud.ioに生息する老害 好きなものopenSUSE 仮想化技術 GPU","link":"/about/index.html"},{"title":"カテゴリー","text":"","link":"/categories/index.html"},{"title":"タグ","text":"","link":"/tags/index.html"}],"posts":[{"title":"blog建てた","text":"これまで諸々の実験やら作業の記録はgistに書き残していたのだけど、blog式の方が良いかなということで、github pagesに建てました gistの方の記事もこちらに追い追い転載していくと思います 多分openSUSE関連のことをつらつら書いていくんじゃないでしょうか","link":"/2999/12/31/firstpost/"},{"title":"openSUSE Tumbleweed上のKVM仮想マシンでIntel iGPUを共有する(GVT-g)その１","text":"KVMやXenといったLinuxハイバーバイザ上のVMでGPUを使用する場合、GPUパススルーを用いてVM一つにGPUをまるごと渡してしまうのが個人ユースでは一般的です GPUパススルーを用いた場合、VM一つがGPUを専有してしまうため、使用できるVMの数に制約があったり、そもそもノートPCのように物理的にGPUが増設できない環境が存在したりと制約が多いのが難点でした これまでも一部のエンタープライズ向けGPUではGPUの共有機能はサポートされていましたが、最近のカーネル（実用レベルになってきたのは4.18ぐらいから）ではIntel GVT-gと呼ばれるIntel iGPUの共有機能が使えるようになってきました。 今回はopenSUSE Tumbleweedを用いてGVT-gによる複数VMでのGPU共有を行ってみます テスト環境 initramfsへのモジュール展開 カーネルパラーメータの設定 共有GPUの確保と開放 サービス化 テスト環境現時点のカーネル(4.20)ではGVT-gはBroadwell〜KabyLakeまでのGPUしかサポートされていません カーネル4.21(仮)でCoffeeLakeに対応する予定（Intelがプルリク投げている）です ということで、SkyLake世代のノートPCでテストしてみました 大須のPCコンフルの初売りで29800円でしたが、SkyLake世代の中古PCも値頃になってきましたね DELL Latitude E5470 CPU: Intel Core i5 6200U GPU: Intel UHD Graphics 520 Mem: 8GB OS: openSUSE Tumbleweed x86_64 qemu: 3.1.0 とりあえずYaSTなりでvirt-manager経由でVMの制御が行えていることを前提とします initramfsへのモジュール展開まずはGVT-gを使うために必要なカーネルモジュールの準備をします。 ブート時点で関連モジュールが必要になるため、dracut.confに必要なモジュールを列挙してinitramfsに突っ込んでおきます 12# echo &quot;drivers+=\\&quot;kvmgt vfio-iommu-type1 vfio-mdev\\&quot;&quot; &gt; /etc/dracut.conf.d/98-gvtg.conf# mkinitrd kvmgtとvfio-mdevが今回のキーモジュールです カーネルパラーメータの設定YaST &gt; システム &gt; ブートローダーを呼び出し、カーネルパラメータに1i915.enable_gvt=1 kvm_ignore_msrs=1 intel_iommu=1 を追加し、GVT-gを有効にします 設定後、再起動して 123456$sudo lspci00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Host Bridge/DRAM Registers (rev 08)00:02.0 VGA compatible controller: Intel Corporation Skylake GT2 [HD Graphics 520] (rev 07)00:04.0 Signal processing controller: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem (rev 08)00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller (rev 21)〜以下略〜 でGPUのPCIアドレスを確認したら 1ls /sys/device/[GPUのPCIアドレス]/mdev_supported_types/ で使える共有GPUの一覧が取れたら成功です12$ ls /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_4 i915-GVTg_V5_8 1cat /sys/device/[GPUのPCIアドレス]/mdev_supported_types/[出てきた共有GPU]/description で共有GPUの詳細を確認できますので確認しておきます 12345678910111213$ cat /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_4/description low_gm_size: 128MBhigh_gm_size: 512MBfence: 4resolution: 1920x1200weight: 4$ cat /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_8/description low_gm_size: 64MBhigh_gm_size: 384MBfence: 4resolution: 1024x768weight: 2 fenceとweightに注目してください fence = この環境で使える最大共有GPU枠 weight = この共有GPU一つで専有する共有GPU枠 なので、今回の環境では1920x1080、VRAM128MB〜512MBが１枚、もしくは1024x768、VRAM64MB〜384MBが２枚取れることがわかります 共有GPUの確保と開放共有GPUを確保するためには1echo &apos;[任意のUUID]&apos; &gt; /sys/devices/[GPUのPCIアドレス]/mdev_supported_types/[共有GPU]/create を行います。成功すれば1ls /sys/device/[GPUのPCIアドレス]/ でデバイスディレクトリ下に与えたUUIDのディレクトリが登場します。123456789$ ls -l /sys/devices/pci0000\\:00/0000\\:00\\:02.0/合計 0drwxr-xr-x 4 root root 0 1月 23 04:14 ab8c3af8-8366-449d-8489-fe9254e44621 ←こいつ-r--r--r-- 1 root root 4096 1月 23 04:14 ari_enabled-r--r--r-- 1 root root 4096 1月 23 04:14 boot_vga-rw-r--r-- 1 root root 4096 1月 23 04:14 broken_parity_status-r--r--r-- 1 root root 4096 1月 23 04:14 class-rw-r--r-- 1 root root 4096 1月 23 04:14 config〜以下略〜 確保した共有GPUを開放するには1echo &apos;1&apos; &gt; /sys/devices/[GPUのPCIアドレス]/[確保の時使ったUUID]/remove を行います UUIDはuuidgenなりで適当に決めてください サービス化システム起動時に共有GPUを自動で確保できるようにsystemdサービスを作ります /usr/lib/systemd/systemの下に任意のサービス名でserviceファイルを作ります 今回はgvtgpu.serviceということで 12345678910111213$ cat /usr/lib/systemd/system/gvtgpu.service [Unit]Description=Create Intel GVT-g vGPU[Service]Type=oneshotExecStart=/bin/sh -c &quot;echo &apos;ab8c3af8-8366-449d-8489-fe9254e44621&apos; &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_4/create&quot;ExecStop=/bin/sh -c &quot;echo &apos;1&apos; &gt; /sys/devices/pci0000:00/0000:00:02.0/ab8c3af8-8366-449d-8489-fe9254e44621/remove&quot;RemainAfterExit=yes[Install]WantedBy=graphical.target ↑のような感じで作りました これで1sudo systemctl start gvtgpu で確保され1sudo systemctl stop gvtgpu で開放され1sudo systemctl enable gvtgpu で起動時に自動確保されるようになります 私の場合ですが、 UUIDその１でi915-GVTg_V5_4を確保するgvtgpu.service UUIDその１でi915-GVTg_V5_8を確保するgvtgpu2.service UUIDその２でi915-GVTg_V5_8を確保するgvtgpu3.service の3つを作り、１枚確保の時はgvtgpuを、２枚確保の時はgvtgpu2と3をenableにする。という運用を行っています とりあえずここまでとし、実際のVMに適用してみる部分はその２にてで (続く)","link":"/2019/01/23/gvtg/"},{"title":"openSUSE Leap 15でNVENCを有効にしたffmpegをビルドし、mpeg2-tsのGPUエンコードを行う","text":"Gistから転載 Nvidia GPUが存在するLinux環境では、NVIDIAのハードウェアエンコーディング/デコーディング機能であるNVENC/NVDECが利用可能ですが、openSUSEの標準パッケージとして利用可能なffmpegではNVENC/NVDECが有効化されていません。これはNVIDIAのライセンス規約により同機能を有効にしたffmpegのバイナリ再配布が許されていないためです。(おそらくほとんどのディストリビューション添付のffmpegも同じはず） そこで、ffmpegをソースからビルドし、NVENC/NVDECを使えるようにします ビルド依存環境のダウンロード CUDA ToolkitとNVIDIA Video SDKのインストール ffmpegのソース取得 configure make 使用可能オプション 基本形 デコーダ(mpeg2_cuvid) リサイズ インターレース解除 クロップ(トリミング） エンコーダ(h264_nvenc) ビットレート指定 プリセット ゼロレイテンシ エンコードテスト テスト環境 サイズ1920x1080/-vbr_hqのみ サイズ1920x1080&amp;インターレース解除/-vbr_hqのみ サイズ1920x1080&amp;インターレース解除/ビットレート3M サイズ1440x810&amp;インターレース解除/-vbr_hqのみ サイズ1280x720&amp;インターレース解除/ビットレート1.5M サイズ1080x810(4:3トリミング)&amp;インターレース解除/-vbr_hqのみ GTX1080との比較 まとめ ビルド依存環境のダウンロードzypperでffmpegに必要な各種ライブラリとツールをダウンロードします 1zypper si -d ffmpeg CUDA ToolkitとNVIDIA Video SDKのインストールffmpegでハードウェアによるリサイズやデインターレース等のフィルター機能を使う場合、CUDAライブラリの一つ、libnppが必要になりますのでこれもインストールします 1234wget https://developer.download.nvidia.com/compute/cuda/repos/opensuse15/x86_64/cuda-repo-opensuse15-10.0.130-1.x86_64.rpmsudo zypper in ./cuda-repo-opensuse15-10.0.130-1.x86_64.rpmsudo zypper refsudo zypper in cuda-toolkit-10-0 cuda-npp-dev-10-0 NVIDIA Video SDKはVLCプロジェクトがgitレポジトリをホストしていますのでこれを入れます123git clone https://git.videolan.org/git/ffmpeg/nv-codec-headers.gitcd nv-codec-headerssudo make install ffmpegのソース取得ffmpegのgithubリポジトリから最新のソースをダウンロードします 1git clone git://github.com/FFmpeg/FFmpeg ffmpeg/ configureffmpegになにもオプションを与えずに実行すると、そのffmpegがどういうオプションでコンパイルされているかを把握できるので、これをどこかにメモするなりコピペするなりで覚えておきます 123456789101112131415161718$ffmpegffmpeg version 4.1 Copyright (c) 2000-2018 the FFmpeg developers built with gcc 7 (SUSE Linux) configuration: --prefix=/usr --libdir=/usr/lib64 --shlibdir=/usr/lib64 --incdir=/usr/include/ffmpeg --extra-cflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; --optflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; --disable-htmlpages --enable-pic --disable-stripping --enable-shared --disable-static --enable-gpl --disable-openssl --enable-avresample --enable-gnutls --enable-ladspa --enable-nvenc --enable-libfdk_aac --enable-nonfree --enable-nvdec --enable-libx264 --enable-libx265 --enable-vaapi --enable-vdpau --enable-libxvid --enable-cuda --enable-cuvid --disable-cuda --disable-cuvid --enable-libass --enable-libbluray --enable-libcelt --enable-libcdio --enable-libdc1394 --enable-libdrm --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libopenjpeg --enable-libopus --enable-libpulse --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libv4l2 --enable-libvpx --enable-libwebp --enable-libxml2 --enable-libzvbi --enable-vaapi --enable-vdpau libavutil 56. 22.100 / 56. 22.100 libavcodec 58. 35.100 / 58. 35.100 libavformat 58. 20.100 / 58. 20.100 libavdevice 58. 5.100 / 58. 5.100 libavfilter 7. 40.101 / 7. 40.101 libavresample 4. 0. 0 / 4. 0. 0 libswscale 5. 3.100 / 5. 3.100 libswresample 3. 3.100 / 3. 3.100 libpostproc 55. 3.100 / 55. 3.100Hyper fast Audio and Video encoderusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...Use -h to get full help or, even better, run &apos;man ffmpeg&apos; 上記で確認したオプションに少々手を加えてconfigureします。ポイントとしては /usr/local/lib/cuda /usr/local/include/cudaをパスに加える prefixを/usr/localにする –enable-cuda-sdkと–enable-libnppを入れる –disable-cuda等があったら抜く –enable-libzbviを外す（2019/1/16現在、どうにも依存関係が解決できなかったのと、無くてもさほど困らないと判断して）1234567891011121314--prefix=/usr/local --libdir=/usr/lib64 --shlibdir=/usr/lib64 \\--extra-cflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; \\--optflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; \\--disable-htmlpages --enable-pic --disable-stripping --enable-shared --disable-static --enable-gpl --disable-openssl --enable-avresample \\--enable-gnutls --enable-ladspa --enable-nvenc --enable-libfdk_aac --enable-nonfree --enable-nvdec --enable-libx264 --enable-libx265 \\--enable-vaapi --enable-vdpau --enable-libxvid --enable-cuda --enable-cuvid --enable-libass \\--enable-libbluray --enable-libcelt --enable-libcdio --enable-libdc1394 --enable-libdrm \\--enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgsm \\--enable-libjack --enable-libmp3lame --enable-libopenjpeg --enable-libopus --enable-libpulse \\--enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libv4l2 \\--enable-libvpx --enable-libwebp --enable-libxml2 --enable-vaapi --enable-vdpau \\--enable-cuda-sdk --enable-npp \\--extra-cflags=&quot;-I/usr/local/cuda/include/&quot; \\--extra-ldflags=-L/usr/local/cuda/lib64/ configureを実行すると依存関係であれがないこれがないと言われるはずなのでそれらを導入します1sudo zypper in libx264-devel libx265-devel fdk-aac-devel openjpeg2-devel libssh-devel libxvidcore-devel configureが通ると、このconfigで使用可能になっているデコーダー/エンコーダー/フィルタ等がリストアップされますので、この中にh264_cuvid、h264_nvenc、yadif_cuda、scale_npp等があればOKです 12345678910111213141516171819202122232425262728install prefix /usr/localsource path .C compiler gcc～略～External libraries providing hardware acceleration:cuda libnpp v4l2_m2mcuda_sdk nvdec vaapicuvid nvenc vdpauffnvcodecEnabled decoders:～略～adpcm_ima_wav cpia h264_cuvid～略～Enabled encoders:～略～h264_nvenc pcm_s24le_planar wmav2～略～Enabled hwaccels:～略～h264_nvdec mpeg1_vdpau vc1_vdpau～略～Enabled filters:～略～mcompand scale_npp tile～略～pixdesctest silenceremove yadif_cuda～略～ makecudaを有効にしている場合、makeの中でcuda toolkitのnvccを使うので、PATHに/usr/local/cuda/binを追加で通してmakeします12PATH=$PATH:/usr/local/cuda/bin makesudo make install これで/usr/local/binにnvencが有効になったffmpegが配置されます 使用可能オプション基本形1ffmpeg -c:v mpeg2_cuvid [デコーダ側オプション] -i input.ts [必要ならフィルター指定] -c:v h264_nvenc [エンコーダ側オプション] output.mp4 デコーダ(mpeg2_cuvid)h264_cuvid,hevc_cuvid等もありますが基本的には同じです 以下のようなオプションがありますので、cuvidを使う場合はリサイズやインターレース解除といった基本的な処理はfilterを使わずにデコーダで行います1234567891011$ffmpeg -h decoder=mpeg2_cuvidmpeg2_cuvid AVOptions: -deint &lt;int&gt; .D.V..... Set deinterlacing mode (from 0 to 2) (default weave) weave .D.V..... Weave deinterlacing (do nothing) bob .D.V..... Bob deinterlacing adaptive .D.V..... Adaptive deinterlacing -gpu &lt;string&gt; .D.V..... GPU to be used for decoding -surfaces &lt;int&gt; .D.V..... Maximum surfaces to be used for decoding (from 0 to INT_MAX) (default 25) -drop_second_field &lt;boolean&gt; .D.V..... Drop second field when deinterlacing (default false) -crop &lt;string&gt; .D.V..... Crop (top)x(bottom)x(left)x(right) -resize &lt;string&gt; .D.V..... Resize (width)x(height) リサイズ1-resize 1280x720 地上デジタル放送や一部BS/CSにある、1440x1080といったソースは、デコーダ側で16:9にリサイズしてエンコーダに渡したほうが良好な結果が出ます（1440x1080を1920x1080にリサイズしてエンコードしても最終サイズは誤差レベルでした） インターレース解除1-deint adaptive -drop_second_field 1 -deintオプション単独で付与すると、その時点でフレーム数が２倍になるので、一般的録画エンコード目的では-drop_second_fieldとセットで使用します クロップ(トリミング）1-crop 10x10x80x80 上記の例では、上下10ピクセル、左右80ピクセルをトリミングしています エンコーダ(h264_nvenc)hevc_nvenc等もありますが基本的には同じですたくさんあるので主に使うものだけ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091h264_nvenc AVOptions: -preset &lt;int&gt; E..V..... Set the encoding preset (from 0 to 11) (default medium) default E..V..... slow E..V..... hq 2 passes medium E..V..... hq 1 pass fast E..V..... hp 1 pass hp E..V..... hq E..V..... bd E..V..... ll E..V..... low latency llhq E..V..... low latency hq llhp E..V..... low latency hp lossless E..V..... losslesshp E..V..... -profile &lt;int&gt; E..V..... Set the encoding profile (from 0 to 3) (default main) baseline E..V..... main E..V..... high E..V..... high444p E..V..... -level &lt;int&gt; E..V..... Set the encoding level restriction (from 0 to 51) (default auto) auto E..V..... 1 E..V..... 1.0 E..V..... 1b E..V..... 1.0b E..V..... 1.1 E..V..... 1.2 E..V..... 1.3 E..V..... 2 E..V..... 2.0 E..V..... 2.1 E..V..... 2.2 E..V..... 3 E..V..... 3.0 E..V..... 3.1 E..V..... 3.2 E..V..... 4 E..V..... 4.0 E..V..... 4.1 E..V..... 4.2 E..V..... 5 E..V..... 5.0 E..V..... 5.1 E..V..... -rc &lt;int&gt; E..V..... Override the preset rate-control (from -1 to INT_MAX) (default -1) constqp E..V..... Constant QP mode vbr E..V..... Variable bitrate mode cbr E..V..... Constant bitrate mode vbr_minqp E..V..... Variable bitrate mode with MinQP (deprecated) ll_2pass_quality E..V..... Multi-pass optimized for image quality (deprecated) ll_2pass_size E..V..... Multi-pass optimized for constant frame size (deprecated) vbr_2pass E..V..... Multi-pass variable bitrate mode (deprecated) cbr_ld_hq E..V..... Constant bitrate low delay high quality mode cbr_hq E..V..... Constant bitrate high quality mode vbr_hq E..V..... Variable bitrate high quality mode -rc-lookahead &lt;int&gt; E..V..... Number of frames to look ahead for rate-control (from 0 to INT_MAX) (default 0) -surfaces &lt;int&gt; E..V..... Number of concurrent surfaces (from 0 to 64) (default 0) -cbr &lt;boolean&gt; E..V..... Use cbr encoding mode (default false) -2pass &lt;boolean&gt; E..V..... Use 2pass encoding mode (default auto) -gpu &lt;int&gt; E..V..... Selects which NVENC capable GPU to use. First GPU is 0, second is 1, and so on. (from -2 to INT_MAX) (default any) any E..V..... Pick the first device available list E..V..... List the available devices -delay &lt;int&gt; E..V..... Delay frame output by the given amount of frames (from 0 to INT_MAX) (default INT_MAX) -no-scenecut &lt;boolean&gt; E..V..... When lookahead is enabled, set this to 1 to disable adaptive I-frame insertion at scene cuts (default false) -forced-idr &lt;boolean&gt; E..V..... If forcing keyframes, force them as IDR frames. (default false) -b_adapt &lt;boolean&gt; E..V..... When lookahead is enabled, set this to 0 to disable adaptive B-frame decision (default true) -spatial-aq &lt;boolean&gt; E..V..... set to 1 to enable Spatial AQ (default false) -temporal-aq &lt;boolean&gt; E..V..... set to 1 to enable Temporal AQ (default false) -zerolatency &lt;boolean&gt; E..V..... Set 1 to indicate zero latency operation (no reordering delay) (default false) -nonref_p &lt;boolean&gt; E..V..... Set this to 1 to enable automatic insertion of non-reference P-frames (default false) -strict_gop &lt;boolean&gt; E..V..... Set 1 to minimize GOP-to-GOP rate fluctuations (default false) -aq-strength &lt;int&gt; E..V..... When Spatial AQ is enabled, this field is used to specify AQ strength. AQ strength scale is from 1 (low) - 15 (aggressive) (from 1 to 15) (default 8) -cq &lt;float&gt; E..V..... Set target quality level (0 to 51, 0 means automatic) for constant quality mode in VBR rate control (from 0 to 51) (default 0) -aud &lt;boolean&gt; E..V..... Use access unit delimiters (default false) -bluray-compat &lt;boolean&gt; E..V..... Bluray compatibility workarounds (default false) -init_qpP &lt;int&gt; E..V..... Initial QP value for P frame (from -1 to 51) (default -1) -init_qpB &lt;int&gt; E..V..... Initial QP value for B frame (from -1 to 51) (default -1) -init_qpI &lt;int&gt; E..V..... Initial QP value for I frame (from -1 to 51) (default -1) -qp &lt;int&gt; E..V..... Constant quantization parameter rate control method (from -1 to 51) (default -1) -weighted_pred &lt;int&gt; E..V..... Set 1 to enable weighted prediction (from 0 to 1) (default 0) -coder &lt;int&gt; E..V..... Coder type (from -1 to 2) (default default) default E..V..... auto E..V..... cabac E..V..... cavlc E..V..... ac E..V..... vlc E..V..... -b_ref_mode &lt;int&gt; E..V..... Use B frames as references (from 0 to 2) (default disabled) disabled E..V..... B frames will not be used for reference each E..V..... Each B frame will be used for reference middle E..V..... Only (number of B frames)/2 will be used for reference -a53cc &lt;boolean&gt; E..V..... Use A53 Closed Captions (if available) (default true) ビットレート指定基本的にファイルへのエンコードであれば -rc vbr_hqを、リアルタイムトランスコードであればcbr_ld_hqを指定すれば大丈夫です （手元の環境では-vbr-hq指定がqp指定やcq指定より良好な結果が出ました） 1-vb 3M -rc vbr_hq デコーダでソースを1280x720等にリサイズ済であればデフォルトの2M、1920x1080の場合で3Mぐらいあれば十分かと思います プリセットファイルエンコードであれば無指定(medium)で良いと思います （もっともslowにして2passにしても劇的に画質が改善されるというほどでもない説） リアルタイムトランスコードであればfastか無指定で良いかと ゼロレイテンシ1-zerolatency 1 リアルタイムトランスコードの場合、これを付けるとストリーム開始の待ちがほぼなくなります エンコードテスト2019/01/16現在でのffmpegのエンコードテスト結果を残しておきます テスト環境openSUSE Leap 15 on openSUSE Leap 15 with KVM(GPUパススルーで750Tiを渡しています） GPU: NVIDIA Geforce 750Ti CPU: Intel Xeon E3 1245V2(Ivybridge) 3.0GHz VCPU 4Core Mem 4GB ソース：地デジタル放送録画ファイル（30分のアニメ3.7GB 1440x1080) サイズ1920x1080/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 7.5倍速 ファイルサイズ : 532M ちょっと保存には使えないレベル、画質を気にしない番組ならまあ。ぐらい サイズ1920x1080&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 6倍速 ファイルサイズ : 508M インターレース解除によりサイズが縮む。画質もかなり見られるようになる。家族にQSVエンコードした同サイズ動画とブラインドテストしてもらったけど区別がつかなかった サイズ1920x1080&amp;インターレース解除/ビットレート3M1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -vb 3M -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 6倍速 ファイルサイズ : 680M 単純にビットレートが増えた分サイズが大きくなる。保存用にしても良いと思えるレベル（主観） サイズ1440x810&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1440x810 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 9倍速 ファイルサイズ : 492M 速度とサイズと画質のバランスが非常に良い（主観）。1440x1080のソースであればこれで十分説。自分ちの録画サーバーのデフォルトはこの設定にしてる サイズ1280x720&amp;インターレース解除/ビットレート1.5M1ffmpeg -c:v mpeg2_cuvid -resize 1280x720 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -vb 1500k -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 11倍速 ファイルサイズ : 372M スマホ観賞用サイズ。スマホ等で鑑賞する分には全く問題ない。出かける前に電車でこれ見ようとエンコードを開始して、駅までの間にエンコードが終わってるのは便利 サイズ1080x810(4:3トリミング)&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -crop 0x0x180x180 -resize 1080x810 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 4:3 output.mp4 エンコード速度 : 9.5倍速 ファイルサイズ : 402M 4:3のソースをトリミングして容量削減を狙った設定。もともと4:3ソースという時点でソースの画質自体がわりとお察しなのもあり余裕で綺麗。 GTX1080との比較別マシンのGTX1080にてh264テストを行ったところ、エンコード速度は概ね２〜２．５倍程度（1440x810で20倍速ぐらい）になったが、最終サイズは1MB未満の差しかなく、画質面では有意な差は感じられなかった。最近NVENCが画質面でもQSVにかなり追いついたと言われるが、ドライバ層での改善による点が大きいと思われる まとめQSVと比較すると画質面で落ちる落ちると言われていたNVENCですが、最近はドライバとffmpegの改善により以前ほど差がない、というよりHEVCでは逆転現象すら起きている状態です。是非一度試してみてください","link":"/2019/01/22/ffmpeg-nvenc/"},{"title":"virtio-gpu環境でopenGL-ES入りandroid-x86を動かす","text":"android-x86の8.1r1が出たので、KVM環境で動かしてみました。 Linuxデスクトップ上でAndroidアプリを動かす試みとしてはanboxとかもあり、これもコンテナの下で動くAndroidということで非常に興味深いプロジェクトですが、まだopenSUSE上でまともに動かすことに成功していないのと、この間arch上で動いているanboxを東海道らぐの会合で見ましたが、まだまともに動かないアプリも結構あり、じゃあ最近のKVM環境で動かしたらどうなんかなということで試してみました。 今回はGPUおたくらしくvirtio-gpu(VirGL3d)を使ってopenGL-ESを有効にしたandroid-x86を動かしてみます virtio-gpu(VirGL3D)とは テスト環境 ISOのダウンロード ゲストの作成 virtio-gpuを設定する 動かしてみて まとめ virtio-gpu(VirGL3D)とはVirGL3Dとは仮想環境でGPUを扱うための準仮想化システムであり、GPUパススルーやGPU共有と異なり、独自のAPIを持った独立GPUとして扱うものです。 VMWareやVirtualboxの仮想GPUなどとほぼ同じものと考えて良いでしょう まだWindows Driverが未完成（openGLは動き始めたがDirectXが動かない）だったりと発展途上のプロジェクトではありますが、X11やAndoroidではそこそこまっとうに動くようになってきています テスト環境今回もパッケージが新しければ新しいほど良いという感じの実験なのでopenSUSE Tumbleweedを使います DELL Latitude E5470 CPU: Intel Core i5 6200U GPU: Intel UHD Graphics 520 Mem: 8GB OS: openSUSE Tumbleweed x86_64 qemu: 3.1.0 例によってvirt-managerでVMの制御ができるようにまではなっている前提で。 ISOのダウンロードandroid-x86公式から8.1r1のx86-64版isoをダウンロードします ゲストの作成virt-managerからisoを選んでゲストのインストールを行います もともと古いPC等に入れて使うことを想定されていることもあり、デフォルトテンプレートで一番相性が良いテンプレートがWindows 10だったりしますのでそうします あとは粛々とウィザードを最後まで進めて行けばOKですが、最後の「インストール前に設定を確認する」にチェックを入れてください virtio-gpuを設定する「インストール前に設定を確認する」にチェックを入れて完了すると、そのままVMの設定が開きますので、「ディスプレイ：Spiceを選びます」 ここでリッスンタイプを「なし」にして、「GLを開く」をONにすると、レンダリングを受け持つGPUが出てきますので、Intel HD Graphicsを選びます 残念ながら、2019-1-23現在、AMDのGPUはlibvirtからvirtio-gpuのレンダリングデバイスに指定しても動かないので注意してください これはmesaの仕様で、GLSLシェーダーキャッシュをディスク上に作ろうとしますが、libvirtでは現在そのあたりを考慮せず存在しないディレクトリにキャッシュを作ろうとして起動に失敗します （コマンドラインからqemuを直に呼べばいけると思いますが未検証） 続いて、ビデオを選び、「モデル」にvirtioを選んで3DアクセラレーションをONにします これで「インストールを開始」を選べばandroid-x86のライブCDが起動するはずですが、時々libvirtのバグでEGLデバイスが確保的ないというエラーが出ることがあります ディスプレイの設定画面に再度戻るとデバイスを設定したはずなのに、デバイスが「自動」になっていますので改めてデバイスを指定してください あとは普通にライブが起動するはずなので、普通にインストールすればOKです Android x86のインストール手順そのものはぐぐればいくらでも出てくると思いますので割愛します 動かしてみてOSそのものはかなりサクサク動きます。 （正直手元の古いAndroid4.4タブレットより軽いんじゃないか説） ゲーム類は、そもそも起動しないタイトルがあったり、マウス操作を受け付けないタイトルがあったりはしますが、マウス操作でいけるタイプのタイトルであれば予想以上に実用レベルで動きます 以下のスクリーンショットは、検証用に適当にPlayストアから拾ってきた「ドールズフロントライン」というゲームですが、割と軽めの2Dゲームということもあり全く問題なく動きました スワイプ動作を受け付けないため、カメラ操作ができませんが、「カスタムキャスト」あたりのかなり重いタイトルでも動くには動いています まとめVirGL3Dを使うことで、制約はあれこれありますが、openGL-ESが使える仮想android環境がopenSUSE TumbleweedのKVMで割と簡単に実現できますので、よろしければぜひ一度お試しください","link":"/2019/01/24/virgl-android-x86/"}],"tags":[{"name":"misc","slug":"misc","link":"/tags/misc/"},{"name":"openSUSE","slug":"openSUSE","link":"/tags/openSUSE/"},{"name":"KVM","slug":"KVM","link":"/tags/KVM/"},{"name":"GVT-g","slug":"GVT-g","link":"/tags/GVT-g/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"仮想化","slug":"仮想化","link":"/tags/仮想化/"},{"name":"ffmpeg","slug":"ffmpeg","link":"/tags/ffmpeg/"},{"name":"VirGL","slug":"VirGL","link":"/tags/VirGL/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"openSUSE","slug":"Linux/openSUSE","link":"/categories/Linux/openSUSE/"}]}