{"pages":[{"title":"About","text":"お前誰よ？mstdn.maud.ioに生息する老害 好きなものopenSUSE 仮想化技術 GPU","link":"/about/index.html"},{"title":"タグ","text":"","link":"/tags/index.html"},{"title":"カテゴリー","text":"","link":"/categories/index.html"}],"posts":[{"title":"blog建てた","text":"これまで諸々の実験やら作業の記録はgistに書き残していたのだけど、blog式の方が良いかなということで、github pagesに建てました gistの方の記事もこちらに追い追い転載していくと思います 多分openSUSE関連のことをつらつら書いていくんじゃないでしょうか","link":"/2999/12/31/firstpost/"},{"title":"openSUSE Tumbleweed上のKVM仮想マシンでIntel iGPUを共有する(GVT-g)その１","text":"KVMやXenといったLinuxハイバーバイザ上のVMでGPUを使用する場合、GPUパススルーを用いてVM一つにGPUをまるごと渡してしまうのが個人ユースでは一般的です GPUパススルーを用いた場合、VM一つがGPUを専有してしまうため、使用できるVMの数に制約があったり、そもそもノートPCのように物理的にGPUが増設できない環境が存在したりと制約が多いのが難点でした これまでも一部のエンタープライズ向けGPUではGPUの共有機能はサポートされていましたが、最近のカーネル（実用レベルになってきたのは4.18ぐらいから）ではIntel GVT-gと呼ばれるIntel iGPUの共有機能が使えるようになってきました。 今回はopenSUSE Tumbleweedを用いてGVT-gによる複数VMでのGPU共有を行ってみます テスト環境 initramfsへのモジュール展開 カーネルパラーメータの設定 共有GPUの確保と開放 サービス化 テスト環境現時点のカーネル(4.20)ではGVT-gはBroadwell〜KabyLakeまでのGPUしかサポートされていません カーネル4.21(仮)でCoffeeLakeに対応する予定（Intelがプルリク投げている）です ということで、SkyLake世代のノートPCでテストしてみました 大須のPCコンフルの初売りで29800円でしたが、SkyLake世代の中古PCも値頃になってきましたね DELL Latitude E5470 CPU: Intel Core i5 6200U GPU: Intel UHD Graphics 520 Mem: 8GB OS: openSUSE Tumbleweed x86_64 qemu: 3.1.0 とりあえずYaSTなりでvirt-manager経由でVMの制御が行えていることを前提とします initramfsへのモジュール展開まずはGVT-gを使うために必要なカーネルモジュールの準備をします。 ブート時点で関連モジュールが必要になるため、dracut.confに必要なモジュールを列挙してinitramfsに突っ込んでおきます 12# echo &quot;drivers+=\\&quot;kvmgt vfio-iommu-type1 vfio-mdev\\&quot;&quot; &gt; /etc/dracut.conf.d/98-gvtg.conf# mkinitrd kvmgtとvfio-mdevが今回のキーモジュールです カーネルパラーメータの設定YaST &gt; システム &gt; ブートローダーを呼び出し、カーネルパラメータに1i915.enable_gvt=1 kvm_ignore_msrs=1 intel_iommu=1 を追加し、GVT-gを有効にします 設定後、再起動して 123456$sudo lspci00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Host Bridge/DRAM Registers (rev 08)00:02.0 VGA compatible controller: Intel Corporation Skylake GT2 [HD Graphics 520] (rev 07)00:04.0 Signal processing controller: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem (rev 08)00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller (rev 21)〜以下略〜 でGPUのPCIアドレスを確認したら 1ls /sys/device/[GPUのPCIアドレス]/mdev_supported_types/ で使える共有GPUの一覧が取れたら成功です12$ ls /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_4 i915-GVTg_V5_8 1cat /sys/device/[GPUのPCIアドレス]/mdev_supported_types/[出てきた共有GPU]/description で共有GPUの詳細を確認できますので確認しておきます 12345678910111213$ cat /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_4/description low_gm_size: 128MBhigh_gm_size: 512MBfence: 4resolution: 1920x1200weight: 4$ cat /sys/devices/pci0000\\:00/0000\\:00\\:02.0/mdev_supported_types/i915-GVTg_V5_8/description low_gm_size: 64MBhigh_gm_size: 384MBfence: 4resolution: 1024x768weight: 2 fenceとweightに注目してください fence = この環境で使える最大共有GPU枠 weight = この共有GPU一つで専有する共有GPU枠 なので、今回の環境では1920x1080、VRAM128MB〜512MBが１枚、もしくは1024x768、VRAM64MB〜384MBが２枚取れることがわかります 共有GPUの確保と開放共有GPUを確保するためには1echo &apos;[任意のUUID]&apos; &gt; /sys/devices/[GPUのPCIアドレス]/mdev_supported_types/[共有GPU]/create を行います。成功すれば1ls /sys/device/[GPUのPCIアドレス]/ でデバイスディレクトリ下に与えたUUIDのディレクトリが登場します。123456789$ ls -l /sys/devices/pci0000\\:00/0000\\:00\\:02.0/合計 0drwxr-xr-x 4 root root 0 1月 23 04:14 ab8c3af8-8366-449d-8489-fe9254e44621 ←こいつ-r--r--r-- 1 root root 4096 1月 23 04:14 ari_enabled-r--r--r-- 1 root root 4096 1月 23 04:14 boot_vga-rw-r--r-- 1 root root 4096 1月 23 04:14 broken_parity_status-r--r--r-- 1 root root 4096 1月 23 04:14 class-rw-r--r-- 1 root root 4096 1月 23 04:14 config〜以下略〜 確保した共有GPUを開放するには1echo &apos;1&apos; &gt; /sys/devices/[GPUのPCIアドレス]/[確保の時使ったUUID]/remove を行います UUIDはuuidgenなりで適当に決めてください サービス化システム起動時に共有GPUを自動で確保できるようにsystemdサービスを作ります /usr/lib/systemd/systemの下に任意のサービス名でserviceファイルを作ります 今回はgvtgpu.serviceということで 12345678910111213$ cat /usr/lib/systemd/system/gvtgpu.service [Unit]Description=Create Intel GVT-g vGPU[Service]Type=oneshotExecStart=/bin/sh -c &quot;echo &apos;ab8c3af8-8366-449d-8489-fe9254e44621&apos; &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_4/create&quot;ExecStop=/bin/sh -c &quot;echo &apos;1&apos; &gt; /sys/devices/pci0000:00/0000:00:02.0/ab8c3af8-8366-449d-8489-fe9254e44621/remove&quot;RemainAfterExit=yes[Install]WantedBy=graphical.target ↑のような感じで作りました これで1sudo systemctl start gvtgpu で確保され1sudo systemctl stop gvtgpu で開放され1sudo systemctl enable gvtgpu で起動時に自動確保されるようになります 私の場合ですが、 UUIDその１でi915-GVTg_V5_4を確保するgvtgpu.service UUIDその１でi915-GVTg_V5_8を確保するgvtgpu2.service UUIDその２でi915-GVTg_V5_8を確保するgvtgpu3.service の3つを作り、１枚確保の時はgvtgpuを、２枚確保の時はgvtgpu2と3をenableにする。という運用を行っています とりあえずここまでとし、実際のVMに適用してみる部分はその２にてで (続く)","link":"/2019/01/23/gvtg/"},{"title":"覚書：openSUSEのインストールメディアのレスキューモードからgrubを再構築する","text":"中華タブにopenSUSEをインストールするために32bit UEFIのインストールUSBを作ろうとした際に、うっかり母艦ノートPCのgrubを壊してしまったのでインストールメディアのrescueモードからgrubを再構築しました そうそう起きることもない事柄なので、毎度毎度どうやるんだっけとopenSUSEの公式Docを漁ることになるので自分用覚書として パーティションの確認 ルートパーティションのマウント proc、dev、sysのマウント chroot grubの再インストール 終了と再起動 パーティションの確認123456# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 128G 0 disk ├─sda1 8:1 0 8M 0 part ├─sda2 8:2 0 124.1G 0 part /opt└─sda3 8:3 0 3.9G 0 part [SWAP] こんな感じで出てくるので、まあ一番大きなパーティションがルートパーティションかなということで、sda2がルートパーティションのようです ルートパーティションのマウント1# mount /dev/sda2 /mnt で、/mntにルートパーティションをマウントします proc、dev、sysのマウント123# mount -t proc none /mnt/proc# mount --rbind /dev /mnt/dev# mount --rbind /sys /mnt/sys で、proc、dev、sysを/mnt下にマウントします chroot1# chroot /mnt /bin/bash 1# mount -a で、以後ルートパーティション下のシステムにアクセスできるようになります(btrfsで相当凝ったマウントをしていても大丈夫) grubの再インストール1# grub2-install /dev/sda 1# grub2-mkconig -o /boot/grub2/grub.cfg 終了と再起動123# umount -a# exit# reboot 以上、チラ裏でした","link":"/2019/01/30/rescue-grub/"},{"title":"virtio-gpu環境でopenGL-ES入りandroid-x86を動かす","text":"android-x86の8.1r1が出たので、KVM環境で動かしてみました。 Linuxデスクトップ上でAndroidアプリを動かす試みとしてはanboxとかもあり、これもコンテナの下で動くAndroidということで非常に興味深いプロジェクトですが、まだopenSUSE上でまともに動かすことに成功していないのと、この間arch上で動いているanboxを東海道らぐの会合で見ましたが、まだまともに動かないアプリも結構あり、じゃあ最近のKVM環境で動かしたらどうなんかなということで試してみました。 今回はGPUおたくらしくvirtio-gpu(VirGL3d)を使ってopenGL-ESを有効にしたandroid-x86を動かしてみます virtio-gpu(VirGL3D)とは テスト環境 ISOのダウンロード ゲストの作成 virtio-gpuを設定する 動かしてみて まとめ virtio-gpu(VirGL3D)とはVirGL3Dとは仮想環境でGPUを扱うための準仮想化システムであり、GPUパススルーやGPU共有と異なり、独自のAPIを持った独立GPUとして扱うものです。 VMWareやVirtualboxの仮想GPUなどとほぼ同じものと考えて良いでしょう まだWindows Driverが未完成（openGLは動き始めたがDirectXが動かない）だったりと発展途上のプロジェクトではありますが、X11やAndoroidではそこそこまっとうに動くようになってきています テスト環境今回もパッケージが新しければ新しいほど良いという感じの実験なのでopenSUSE Tumbleweedを使います DELL Latitude E5470 CPU: Intel Core i5 6200U GPU: Intel UHD Graphics 520 Mem: 8GB OS: openSUSE Tumbleweed x86_64 qemu: 3.1.0 例によってvirt-managerでVMの制御ができるようにまではなっている前提で。 ISOのダウンロードandroid-x86公式から8.1r1のx86-64版isoをダウンロードします ゲストの作成virt-managerからisoを選んでゲストのインストールを行います もともと古いPC等に入れて使うことを想定されていることもあり、デフォルトテンプレートで一番相性が良いテンプレートがWindows 10だったりしますのでそうします あとは粛々とウィザードを最後まで進めて行けばOKですが、最後の「インストール前に設定を確認する」にチェックを入れてください virtio-gpuを設定する「インストール前に設定を確認する」にチェックを入れて完了すると、そのままVMの設定が開きますので、「ディスプレイ：Spiceを選びます」 ここでリッスンタイプを「なし」にして、「GLを開く」をONにすると、レンダリングを受け持つGPUが出てきますので、Intel HD Graphicsを選びます 残念ながら、2019-1-23現在、AMDのGPUはlibvirtからvirtio-gpuのレンダリングデバイスに指定しても動かないので注意してください これはmesaの仕様で、GLSLシェーダーキャッシュをディスク上に作ろうとしますが、libvirtでは現在そのあたりを考慮せず存在しないディレクトリにキャッシュを作ろうとして起動に失敗します （コマンドラインからqemuを直に呼べばいけると思いますが未検証） 続いて、ビデオを選び、「モデル」にvirtioを選んで3DアクセラレーションをONにします これで「インストールを開始」を選べばandroid-x86のライブCDが起動するはずですが、時々libvirtのバグでEGLデバイスが確保的ないというエラーが出ることがあります ディスプレイの設定画面に再度戻るとデバイスを設定したはずなのに、デバイスが「自動」になっていますので改めてデバイスを指定してください あとは普通にライブが起動するはずなので、普通にインストールすればOKです Android x86のインストール手順そのものはぐぐればいくらでも出てくると思いますので割愛します 動かしてみてOSそのものはかなりサクサク動きます。 （正直手元の古いAndroid4.4タブレットより軽いんじゃないか説） ゲーム類は、そもそも起動しないタイトルがあったり、マウス操作を受け付けないタイトルがあったりはしますが、マウス操作でいけるタイプのタイトルであれば予想以上に実用レベルで動きます 以下のスクリーンショットは、検証用に適当にPlayストアから拾ってきた「ドールズフロントライン」というゲームですが、割と軽めの2Dゲームということもあり全く問題なく動きました スワイプ動作を受け付けないため、カメラ操作ができませんが、「カスタムキャスト」あたりのかなり重いタイトルでも動くには動いています まとめVirGL3Dを使うことで、制約はあれこれありますが、openGL-ESが使える仮想android環境がopenSUSE TumbleweedのKVMで割と簡単に実現できますので、よろしければぜひ一度お試しください","link":"/2019/01/24/virgl-android-x86/"},{"title":"webArenaの３６０円VPSにopenSUSE Leap 15をリモートインストールする","text":"これまで、イタリアのaruba.itというところで月1EURのVPSを借りてopenSUSE Leap15を動かしていたのですが、そちらが年明けから月3EURに値上がりをしまして、月1EURじゃなければわざわざ遠いEUのサーバーを借りている理由もないということで引っ越しをしました で、月1〜2ドルもしくは1〜2EURのサーバーを探しましたが、どうにも条件にマッチしたところがなく、だったら回線の速い国内VPSにすっかとなりまして、そういえばwebArenaが値下げして360円プランでもメモリ1Gのディスク20GBになってたなということで借りることにしました が、こちらはOSテンプレートがCentOS6、7とUbuntu18.04しかないため、Ubuntu18.04を踏み台としてopenSUSE Leap 15をリモートインストールすることにしました openSUSE Remote Installとは 踏み台OSのインストール インストーラの取得 IPアドレスの確認 grubエントリーの追加 VPSに接続 インストール後の設定 swapfileの設定 SSH認証方式の変更 まとめ openSUSE Remote InstallとはopenSUSEをインストールする方法としては、一般的な手法としてCDなりUSBメディアなりのインストールメディアから起動してインストーラを立ち上げる方法がありますが、その他に、grubからインストーラのvmlinuzとinitrdを起動してSSH経由でインストールするというリモートインストールという手法があり、公式wikiでも解説されています なので今回はある意味その記事をなぞるだけの手抜き記事でもあります 踏み台OSのインストール今回は踏み台OSとしてubuntu 18.04を使いますのでwebArenaのマニュアルに従ってインストールします。 マニュアルに従えば良いだけなので細かいところは割愛しますが、ubuntuの初期ユーザーと初期パスワードは相当マニュアルを熟読しないとわかりにくいところにありますので注意してください webArenaのubuntuテンプレートはデフォルトで公開鍵認証のみで、パスワード認証はOFFになっていますが、今回リモートインストールのために一時的にパスワード認証を使いますので一度sshd_configを弄ってパスワードログイン有効にしてパスワードログインが可能であることを確認してください（インフラ側ファイアウォール等で塞がれていないことを確認のため） インストーラの取得/bootにインストーラのvmlinuzとinitrdを導入します 公式wikiに書かれているやり方でOKですが、download.opensuse.orgより理研のミラーの方が速いのでこちらを使います12sudo wget --output-document=/boot/vmlinuz.install http://ftp.riken.jp/Linux/opensuse/distribution/leap/15.0/repo/oss/boot/x86_64/loader/linuxsudo wget --output-document=/boot/initrd.install http://ftp.riken.jp/Linux/opensuse/distribution/leap/15.0/repo/oss/boot/x86_64/loader/initrd ちなみに入れるのがLeap 15ではなくTumbleweedならばこう12sudo wget --output-document=/boot/vmlinuz.install http://ftp.riken.jp/Linux/opensuse/tumbleweed/repo/oss/boot/x86_64/loader/linuxsudo wget --output-document=/boot/initrd.install http://ftp.riken.jp/Linux/opensuse/tumbleweed/repo/oss/boot/x86_64/loader/initrd IPアドレスの確認1ip a でVPSのIPアドレスとネットマスクを、1ip route show でゲートウェイを確認しておきます grubエントリーの追加grubにインストーラを起動するメニュー項目を追加して、それをデフォルトにします ubuntuの場合。/etc/grub.d/40_customにメニューエントリを追加します1sudo vi /etc/grub.d/40_custom 123456menuentry &apos;openSUSE install&apos; { insmod gzio set root=&apos;hd0,msdos1&apos; linux /boot/vmlinuz.install noapic usessh=1 sshpassword=&quot;[それなりに複雑なパスワード]&quot; install=http://ftp.riken.jp/Linux/opensuse/distribution/leap/15.0/repo/oss hostip=[調べたIPアドレス] netmask=[調べたネットマスク] gateway=[調べたゲートウェイ] nameserver=1.1.1.1 initrd /boot/initrd.install} Tumbleweedならこう123456menuentry &apos;openSUSE install&apos; { insmod gzio set root=&apos;hd0,msdos1&apos; linux /boot/vmlinuz.install noapic usessh=1 sshpassword=&quot;[それなりに複雑なパスワード]&quot; install=http://ftp.riken.jp/Linux/opensuse/tumbleweed/repo/oss hostip=[調べたIPアドレス] netmask=[調べたネットマスク] gateway=[調べたゲートウェイ] nameserver=1.1.1.1 initrd /boot/initrd.install} パスワードは単純なパスワードだとインストーラ起動時に弾かれて起動しなくなってしまうという罠がありますので、まあそのへんのネットサービス登録時にありがちな 8文字以上 大文字小文字数字記号を必ず混ぜる あたりを守って設定してください nameserverは、みんな大好きgoogle DNS(8.8.8.8)かcloudflareのDNS(1.1.1.1)を使えばOKです メニューエントリを登録したら/etc/default/grubを弄ってデフォルトエントリーにします grub2ではデフォルトエントリーの指定が番号ではなくて名前になっているので注意してください 1sudo vi /etc/default/grub 1GRUB_DEFAULT=&quot;openSUSE install&quot; ここまで編集したら 1sudo update-grub で編集内容を反映させてください ここで設定を間違えるとVPSに接続不能になってしまい、踏み台OSのインストールからやり直しとなりますのでよーく確認してください よく確認した後、vpsをリブートします 1sudo reboot VPSに接続VPSをリブートしたら、VPSにX転送ありで接続すればインストーラが起動できます Linuxデスクトップからの接続であれば1ssh -X [vpsのIPアドレス] で、windowsであればmovaxtermなりのX11ありのターミナルで接続します この時以前に踏み台OSにSSH接続していたのであれば、当然SSHホストキーが変わっていますので、それ相応の処置が必要になりますので注意してください openSUSEインストーラがデバイスを自動認識して、インストールのベースシステムをRAMディスクに展開するまでにそれなりの時間（4〜5分？)がかかりますのでなかなか繋がらないからと言って慌てないよう 先程設定したパスワードを入れてログインすると、以下のようなメッセージが出るはずです12345678Password: openSUSE Leap 15.0 InstallationRun yast.ssh to start the installation./usr/bin/xauth: file /root/.Xauthority does not exist0:install:~ # 指示の通り、yast,sshを実行すればいつものインストーラが立ち上がりますので 1# yast.ssh 言語を日本語に設定してインストーラを開始します 概ねはインストーラに従ってインストールを進めればOKですが パーティション設定だけはwebArenaのローカルルールに従っておいたほうが安全なので独自に設定を行います 「熟練者向けパーティション設定」＞「既存のパーティション設定を元にする」を選んでください webArenaのVPSディスクにはVPSで使って良い20GBの領域と別に、10MBぐらいのVPSメタデータが入ったパーティションが存在しますので、これを壊さないように設定します ディスクsda＞sda1＞「編集」を選びます(スクリーンショットは検証用にローカル環境で建てたVMなのでデバイス名とパーティションサイズが微妙に異なりますがそのへんは読み替えてくださいねで) /dev/sda1を「ext4でフォーマット」で「/にマウント」します swapはインストール後にswapfileを作る方針で（元々のubuntuもswapfile式を使っています） openSUSEらしくbtrfsでフォーマットしたいところですが、改めてwebarenaのテンプレートに戻す必要が出たときにトラブルの元になりそうなので日和りましたｗ コンソール画面が使えないwebArenaの場合、snapperの恩恵もないですし あとはお好みで設定しつつ、最終的にはこんな感じで webarenaの場合、インフラ側でFWを設定する感じなので、openSUSE側のfirewallを切るのも手だと思います。あるいはopenSUSE側でfirewallを受け持ってwebarena側のFWは素通し設定にしてしまうのもありかと思いますが、その場合openSUSE側でfirewall設定をしくじるとコンソール画面のないwebArenaではログイン不能になってしまうので、webArenaのFWに任せたほうが安全だと思います （自分はopenSUSE側のFWを切ってます） あとは普通にインストールが進みますftp.riken.jpを使っていれば１０分前後でしょうか インストール後の設定swapfileの設定スワップが設定されていませんのでswapfileを設定します1234$ free total used free shared buff/cache availableMem: 1003048 64628 741828 7060 196592 788252Swap: 0 0 0 今回は1GBのswap用ファイルを作ります（増やしたければcountを増やしてください）12345678910111213141516$ sudo dd if=/dev/zero of=/swapfile bs=1M count=10241073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.926476 s, 1.2 GB/s$ sudo chmod 600 /swapfile$sudo mkswap /swapfileスワップ空間バージョン 1 を設定します。サイズ = 1024 MiB (1073737728 バイト)ラベルはありません, UUID=cc969dda-914d-4f42-a063-f391baaba9fa$ sudo swapon /swapfile$ free total used free shared buff/cache availableMem: 1003048 65060 62484 7060 875504 777376Swap: 1048572 0 1048572 swapが効くことを確認したら/etc/fstabにswapマウントを追加します 1sudo vi /etc/fstab 1/swapfile swap swap defaults 0 0 SSH認証方式の変更デフォルトではSSHがパスワード認証になっていますので公開鍵認証に切り替えて、ポートもwell knownの22番から変更するのをおすすめします あとはお好きに各種サーバーを設定してください まとめopenSUSEがサポートされていない各種VPSでも、sshで入ることができ、grubを弄ることができればopenSUSEはインストールできますので、ぜひ一度お試しください","link":"/2019/01/28/webarena/"},{"title":"openSUSE Leap 15でNVENCを有効にしたffmpegをビルドし、mpeg2-tsのGPUエンコードを行う","text":"Gistから転載 Nvidia GPUが存在するLinux環境では、NVIDIAのハードウェアエンコーディング/デコーディング機能であるNVENC/NVDECが利用可能ですが、openSUSEの標準パッケージとして利用可能なffmpegではNVENC/NVDECが有効化されていません。これはNVIDIAのライセンス規約により同機能を有効にしたffmpegのバイナリ再配布が許されていないためです。(おそらくほとんどのディストリビューション添付のffmpegも同じはず） そこで、ffmpegをソースからビルドし、NVENC/NVDECを使えるようにします ビルド依存環境のダウンロード CUDA ToolkitとNVIDIA Video SDKのインストール ffmpegのソース取得 configure make 使用可能オプション 基本形 デコーダ(mpeg2_cuvid) リサイズ インターレース解除 クロップ(トリミング） エンコーダ(h264_nvenc) ビットレート指定 プリセット ゼロレイテンシ エンコードテスト テスト環境 サイズ1920x1080/-vbr_hqのみ サイズ1920x1080&amp;インターレース解除/-vbr_hqのみ サイズ1920x1080&amp;インターレース解除/ビットレート3M サイズ1440x810&amp;インターレース解除/-vbr_hqのみ サイズ1280x720&amp;インターレース解除/ビットレート1.5M サイズ1080x810(4:3トリミング)&amp;インターレース解除/-vbr_hqのみ GTX1080との比較 まとめ ビルド依存環境のダウンロードzypperでffmpegに必要な各種ライブラリとツールをダウンロードします 1zypper si -d ffmpeg CUDA ToolkitとNVIDIA Video SDKのインストールffmpegでハードウェアによるリサイズやデインターレース等のフィルター機能を使う場合、CUDAライブラリの一つ、libnppが必要になりますのでこれもインストールします 1234wget https://developer.download.nvidia.com/compute/cuda/repos/opensuse15/x86_64/cuda-repo-opensuse15-10.0.130-1.x86_64.rpmsudo zypper in ./cuda-repo-opensuse15-10.0.130-1.x86_64.rpmsudo zypper refsudo zypper in cuda-toolkit-10-0 cuda-npp-dev-10-0 NVIDIA Video SDKはVLCプロジェクトがgitレポジトリをホストしていますのでこれを入れます123git clone https://git.videolan.org/git/ffmpeg/nv-codec-headers.gitcd nv-codec-headerssudo make install ffmpegのソース取得ffmpegのgithubリポジトリから最新のソースをダウンロードします 1git clone git://github.com/FFmpeg/FFmpeg ffmpeg/ configureffmpegになにもオプションを与えずに実行すると、そのffmpegがどういうオプションでコンパイルされているかを把握できるので、これをどこかにメモするなりコピペするなりで覚えておきます 123456789101112131415161718$ffmpegffmpeg version 4.1 Copyright (c) 2000-2018 the FFmpeg developers built with gcc 7 (SUSE Linux) configuration: --prefix=/usr --libdir=/usr/lib64 --shlibdir=/usr/lib64 --incdir=/usr/include/ffmpeg --extra-cflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; --optflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; --disable-htmlpages --enable-pic --disable-stripping --enable-shared --disable-static --enable-gpl --disable-openssl --enable-avresample --enable-gnutls --enable-ladspa --enable-nvenc --enable-libfdk_aac --enable-nonfree --enable-nvdec --enable-libx264 --enable-libx265 --enable-vaapi --enable-vdpau --enable-libxvid --enable-cuda --enable-cuvid --disable-cuda --disable-cuvid --enable-libass --enable-libbluray --enable-libcelt --enable-libcdio --enable-libdc1394 --enable-libdrm --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libopenjpeg --enable-libopus --enable-libpulse --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libv4l2 --enable-libvpx --enable-libwebp --enable-libxml2 --enable-libzvbi --enable-vaapi --enable-vdpau libavutil 56. 22.100 / 56. 22.100 libavcodec 58. 35.100 / 58. 35.100 libavformat 58. 20.100 / 58. 20.100 libavdevice 58. 5.100 / 58. 5.100 libavfilter 7. 40.101 / 7. 40.101 libavresample 4. 0. 0 / 4. 0. 0 libswscale 5. 3.100 / 5. 3.100 libswresample 3. 3.100 / 3. 3.100 libpostproc 55. 3.100 / 55. 3.100Hyper fast Audio and Video encoderusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...Use -h to get full help or, even better, run &apos;man ffmpeg&apos; 上記で確認したオプションに少々手を加えてconfigureします。ポイントとしては /usr/local/lib/cuda /usr/local/include/cudaをパスに加える prefixを/usr/localにする –enable-cuda-sdkと–enable-libnppを入れる –disable-cuda等があったら抜く –enable-libzbviを外す（2019/1/16現在、どうにも依存関係が解決できなかったのと、無くてもさほど困らないと判断して）1234567891011121314--prefix=/usr/local --libdir=/usr/lib64 --shlibdir=/usr/lib64 \\--extra-cflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; \\--optflags=&apos;-fmessage-length=0 -grecord-gcc-switches -O2 -Wall -D_FORTIFY_SOURCE=2 -fstack-protector-strong -funwind-tables -fasynchronous-unwind-tables -fstack-clash-protection -g&apos; \\--disable-htmlpages --enable-pic --disable-stripping --enable-shared --disable-static --enable-gpl --disable-openssl --enable-avresample \\--enable-gnutls --enable-ladspa --enable-nvenc --enable-libfdk_aac --enable-nonfree --enable-nvdec --enable-libx264 --enable-libx265 \\--enable-vaapi --enable-vdpau --enable-libxvid --enable-cuda --enable-cuvid --enable-libass \\--enable-libbluray --enable-libcelt --enable-libcdio --enable-libdc1394 --enable-libdrm \\--enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgsm \\--enable-libjack --enable-libmp3lame --enable-libopenjpeg --enable-libopus --enable-libpulse \\--enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libv4l2 \\--enable-libvpx --enable-libwebp --enable-libxml2 --enable-vaapi --enable-vdpau \\--enable-cuda-sdk --enable-npp \\--extra-cflags=&quot;-I/usr/local/cuda/include/&quot; \\--extra-ldflags=-L/usr/local/cuda/lib64/ configureを実行すると依存関係であれがないこれがないと言われるはずなのでそれらを導入します1sudo zypper in libx264-devel libx265-devel fdk-aac-devel openjpeg2-devel libssh-devel libxvidcore-devel configureが通ると、このconfigで使用可能になっているデコーダー/エンコーダー/フィルタ等がリストアップされますので、この中にh264_cuvid、h264_nvenc、yadif_cuda、scale_npp等があればOKです 12345678910111213141516171819202122232425262728install prefix /usr/localsource path .C compiler gcc～略～External libraries providing hardware acceleration:cuda libnpp v4l2_m2mcuda_sdk nvdec vaapicuvid nvenc vdpauffnvcodecEnabled decoders:～略～adpcm_ima_wav cpia h264_cuvid～略～Enabled encoders:～略～h264_nvenc pcm_s24le_planar wmav2～略～Enabled hwaccels:～略～h264_nvdec mpeg1_vdpau vc1_vdpau～略～Enabled filters:～略～mcompand scale_npp tile～略～pixdesctest silenceremove yadif_cuda～略～ makecudaを有効にしている場合、makeの中でcuda toolkitのnvccを使うので、PATHに/usr/local/cuda/binを追加で通してmakeします12PATH=$PATH:/usr/local/cuda/bin makesudo make install これで/usr/local/binにnvencが有効になったffmpegが配置されます 使用可能オプション基本形1ffmpeg -c:v mpeg2_cuvid [デコーダ側オプション] -i input.ts [必要ならフィルター指定] -c:v h264_nvenc [エンコーダ側オプション] output.mp4 デコーダ(mpeg2_cuvid)h264_cuvid,hevc_cuvid等もありますが基本的には同じです 以下のようなオプションがありますので、cuvidを使う場合はリサイズやインターレース解除といった基本的な処理はfilterを使わずにデコーダで行います1234567891011$ffmpeg -h decoder=mpeg2_cuvidmpeg2_cuvid AVOptions: -deint &lt;int&gt; .D.V..... Set deinterlacing mode (from 0 to 2) (default weave) weave .D.V..... Weave deinterlacing (do nothing) bob .D.V..... Bob deinterlacing adaptive .D.V..... Adaptive deinterlacing -gpu &lt;string&gt; .D.V..... GPU to be used for decoding -surfaces &lt;int&gt; .D.V..... Maximum surfaces to be used for decoding (from 0 to INT_MAX) (default 25) -drop_second_field &lt;boolean&gt; .D.V..... Drop second field when deinterlacing (default false) -crop &lt;string&gt; .D.V..... Crop (top)x(bottom)x(left)x(right) -resize &lt;string&gt; .D.V..... Resize (width)x(height) リサイズ1-resize 1280x720 地上デジタル放送や一部BS/CSにある、1440x1080といったソースは、デコーダ側で16:9にリサイズしてエンコーダに渡したほうが良好な結果が出ます（1440x1080を1920x1080にリサイズしてエンコードしても最終サイズは誤差レベルでした） インターレース解除1-deint adaptive -drop_second_field 1 -deintオプション単独で付与すると、その時点でフレーム数が２倍になるので、一般的録画エンコード目的では-drop_second_fieldとセットで使用します クロップ(トリミング）1-crop 10x10x80x80 上記の例では、上下10ピクセル、左右80ピクセルをトリミングしています エンコーダ(h264_nvenc)hevc_nvenc等もありますが基本的には同じですたくさんあるので主に使うものだけ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091h264_nvenc AVOptions: -preset &lt;int&gt; E..V..... Set the encoding preset (from 0 to 11) (default medium) default E..V..... slow E..V..... hq 2 passes medium E..V..... hq 1 pass fast E..V..... hp 1 pass hp E..V..... hq E..V..... bd E..V..... ll E..V..... low latency llhq E..V..... low latency hq llhp E..V..... low latency hp lossless E..V..... losslesshp E..V..... -profile &lt;int&gt; E..V..... Set the encoding profile (from 0 to 3) (default main) baseline E..V..... main E..V..... high E..V..... high444p E..V..... -level &lt;int&gt; E..V..... Set the encoding level restriction (from 0 to 51) (default auto) auto E..V..... 1 E..V..... 1.0 E..V..... 1b E..V..... 1.0b E..V..... 1.1 E..V..... 1.2 E..V..... 1.3 E..V..... 2 E..V..... 2.0 E..V..... 2.1 E..V..... 2.2 E..V..... 3 E..V..... 3.0 E..V..... 3.1 E..V..... 3.2 E..V..... 4 E..V..... 4.0 E..V..... 4.1 E..V..... 4.2 E..V..... 5 E..V..... 5.0 E..V..... 5.1 E..V..... -rc &lt;int&gt; E..V..... Override the preset rate-control (from -1 to INT_MAX) (default -1) constqp E..V..... Constant QP mode vbr E..V..... Variable bitrate mode cbr E..V..... Constant bitrate mode vbr_minqp E..V..... Variable bitrate mode with MinQP (deprecated) ll_2pass_quality E..V..... Multi-pass optimized for image quality (deprecated) ll_2pass_size E..V..... Multi-pass optimized for constant frame size (deprecated) vbr_2pass E..V..... Multi-pass variable bitrate mode (deprecated) cbr_ld_hq E..V..... Constant bitrate low delay high quality mode cbr_hq E..V..... Constant bitrate high quality mode vbr_hq E..V..... Variable bitrate high quality mode -rc-lookahead &lt;int&gt; E..V..... Number of frames to look ahead for rate-control (from 0 to INT_MAX) (default 0) -surfaces &lt;int&gt; E..V..... Number of concurrent surfaces (from 0 to 64) (default 0) -cbr &lt;boolean&gt; E..V..... Use cbr encoding mode (default false) -2pass &lt;boolean&gt; E..V..... Use 2pass encoding mode (default auto) -gpu &lt;int&gt; E..V..... Selects which NVENC capable GPU to use. First GPU is 0, second is 1, and so on. (from -2 to INT_MAX) (default any) any E..V..... Pick the first device available list E..V..... List the available devices -delay &lt;int&gt; E..V..... Delay frame output by the given amount of frames (from 0 to INT_MAX) (default INT_MAX) -no-scenecut &lt;boolean&gt; E..V..... When lookahead is enabled, set this to 1 to disable adaptive I-frame insertion at scene cuts (default false) -forced-idr &lt;boolean&gt; E..V..... If forcing keyframes, force them as IDR frames. (default false) -b_adapt &lt;boolean&gt; E..V..... When lookahead is enabled, set this to 0 to disable adaptive B-frame decision (default true) -spatial-aq &lt;boolean&gt; E..V..... set to 1 to enable Spatial AQ (default false) -temporal-aq &lt;boolean&gt; E..V..... set to 1 to enable Temporal AQ (default false) -zerolatency &lt;boolean&gt; E..V..... Set 1 to indicate zero latency operation (no reordering delay) (default false) -nonref_p &lt;boolean&gt; E..V..... Set this to 1 to enable automatic insertion of non-reference P-frames (default false) -strict_gop &lt;boolean&gt; E..V..... Set 1 to minimize GOP-to-GOP rate fluctuations (default false) -aq-strength &lt;int&gt; E..V..... When Spatial AQ is enabled, this field is used to specify AQ strength. AQ strength scale is from 1 (low) - 15 (aggressive) (from 1 to 15) (default 8) -cq &lt;float&gt; E..V..... Set target quality level (0 to 51, 0 means automatic) for constant quality mode in VBR rate control (from 0 to 51) (default 0) -aud &lt;boolean&gt; E..V..... Use access unit delimiters (default false) -bluray-compat &lt;boolean&gt; E..V..... Bluray compatibility workarounds (default false) -init_qpP &lt;int&gt; E..V..... Initial QP value for P frame (from -1 to 51) (default -1) -init_qpB &lt;int&gt; E..V..... Initial QP value for B frame (from -1 to 51) (default -1) -init_qpI &lt;int&gt; E..V..... Initial QP value for I frame (from -1 to 51) (default -1) -qp &lt;int&gt; E..V..... Constant quantization parameter rate control method (from -1 to 51) (default -1) -weighted_pred &lt;int&gt; E..V..... Set 1 to enable weighted prediction (from 0 to 1) (default 0) -coder &lt;int&gt; E..V..... Coder type (from -1 to 2) (default default) default E..V..... auto E..V..... cabac E..V..... cavlc E..V..... ac E..V..... vlc E..V..... -b_ref_mode &lt;int&gt; E..V..... Use B frames as references (from 0 to 2) (default disabled) disabled E..V..... B frames will not be used for reference each E..V..... Each B frame will be used for reference middle E..V..... Only (number of B frames)/2 will be used for reference -a53cc &lt;boolean&gt; E..V..... Use A53 Closed Captions (if available) (default true) ビットレート指定基本的にファイルへのエンコードであれば -rc vbr_hqを、リアルタイムトランスコードであればcbr_ld_hqを指定すれば大丈夫です （手元の環境では-vbr-hq指定がqp指定やcq指定より良好な結果が出ました） 1-vb 3M -rc vbr_hq デコーダでソースを1280x720等にリサイズ済であればデフォルトの2M、1920x1080の場合で3Mぐらいあれば十分かと思います プリセットファイルエンコードであれば無指定(medium)で良いと思います （もっともslowにして2passにしても劇的に画質が改善されるというほどでもない説） リアルタイムトランスコードであればfastか無指定で良いかと ゼロレイテンシ1-zerolatency 1 リアルタイムトランスコードの場合、これを付けるとストリーム開始の待ちがほぼなくなります エンコードテスト2019/01/16現在でのffmpegのエンコードテスト結果を残しておきます テスト環境openSUSE Leap 15 on openSUSE Leap 15 with KVM(GPUパススルーで750Tiを渡しています） GPU: NVIDIA Geforce 750Ti CPU: Intel Xeon E3 1245V2(Ivybridge) 3.0GHz VCPU 4Core Mem 4GB ソース：地デジタル放送録画ファイル（30分のアニメ3.7GB 1440x1080) サイズ1920x1080/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 7.5倍速 ファイルサイズ : 532M ちょっと保存には使えないレベル、画質を気にしない番組ならまあ。ぐらい サイズ1920x1080&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 6倍速 ファイルサイズ : 508M インターレース解除によりサイズが縮む。画質もかなり見られるようになる。家族にQSVエンコードした同サイズ動画とブラインドテストしてもらったけど区別がつかなかった サイズ1920x1080&amp;インターレース解除/ビットレート3M1ffmpeg -c:v mpeg2_cuvid -resize 1920x1080 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -vb 3M -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 6倍速 ファイルサイズ : 680M 単純にビットレートが増えた分サイズが大きくなる。保存用にしても良いと思えるレベル（主観） サイズ1440x810&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -resize 1440x810 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 9倍速 ファイルサイズ : 492M 速度とサイズと画質のバランスが非常に良い（主観）。1440x1080のソースであればこれで十分説。自分ちの録画サーバーのデフォルトはこの設定にしてる サイズ1280x720&amp;インターレース解除/ビットレート1.5M1ffmpeg -c:v mpeg2_cuvid -resize 1280x720 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -vb 1500k -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 16:9 output.mp4 エンコード速度 : 11倍速 ファイルサイズ : 372M スマホ観賞用サイズ。スマホ等で鑑賞する分には全く問題ない。出かける前に電車でこれ見ようとエンコードを開始して、駅までの間にエンコードが終わってるのは便利 サイズ1080x810(4:3トリミング)&amp;インターレース解除/-vbr_hqのみ1ffmpeg -c:v mpeg2_cuvid -crop 0x0x180x180 -resize 1080x810 -deint 2 -drop_second_field 1 -i input.ts -c:v h264_nvenc -rc vbr_hq -c:a aac -b:a 192k -r:a 48000 -ac 2 -f mp4 -aspect 4:3 output.mp4 エンコード速度 : 9.5倍速 ファイルサイズ : 402M 4:3のソースをトリミングして容量削減を狙った設定。もともと4:3ソースという時点でソースの画質自体がわりとお察しなのもあり余裕で綺麗。 GTX1080との比較別マシンのGTX1080にてh264テストを行ったところ、エンコード速度は概ね２〜２．５倍程度（1440x810で20倍速ぐらい）になったが、最終サイズは1MB未満の差しかなく、画質面では有意な差は感じられなかった。最近NVENCが画質面でもQSVにかなり追いついたと言われるが、ドライバ層での改善による点が大きいと思われる まとめQSVと比較すると画質面で落ちる落ちると言われていたNVENCですが、最近はドライバとffmpegの改善により以前ほど差がない、というよりHEVCでは逆転現象すら起きている状態です。是非一度試してみてください","link":"/2019/01/22/ffmpeg-nvenc/"},{"title":"openSUSE Tumbleweed上のKVM仮想マシンでIntel iGPUを共有する(GVT-g)その２","text":"その１で共有GPUの確保と開放までができるようになりましたので、実際のゲストに適用してみます ついでに？virt-managerでwindowsゲストをインストールする際のおすすめ設定の話とかも QEMUゲストの設定 インストールメディアの準備 設定のカスタマイズ 概要 CPU数 ストレージ CDROM NIC ディスプレイ コントローラ Windowsゲストのインストール VirtIOドライバのロード GVTデバイスの設定（第一段階） hostdevの追加 Intelドライバのインストール GVTデバイスの設定（第二段階） XMLスキーマの変更 標準VGAの無効化 GVTデバイスの有効化 起動後の設定 テスト まとめ 付録 QEMUゲストの設定インストールメディアの準備Microsoft公式のメディアクリエイターツールを使用するなりで、Windows10の最新ISOを入手してください もう一つ、virtioドライバーディスクを使用するためvirtio driver isoを入手してください windows driver isoはfedoraやubuntuが公開していますが、基本的にfedoraのもののほうが開発が活発ですのでfedoraのものを使用した方が良いと思います 2019-01-23現在の最新は1.1.60でした 設定のカスタマイズ まずはvirt-managerから新規VMを選んでインストールを開始します 基本的にウィザードに従って(メモリやストレージ、ネットワーク等は個々の環境に合わせてお好みで)最後まで進めばOKですが、最後に「設定をカスタマイズする」にチェックを入れてください 概要ここでBIOS(seabios)起動をするか、UEFI(OVMF)起動をするかを選択します。 2019-01現在、GVT-gデバイスはseabiosでしか表示が正しく動かないので、必ずBIOSを選択してください CPU数 ここ、何気に重要なんですが、Windows 10 Pro/Home等では使用できるCPUソケット数に制限がかかっています virt-managerで3コア以上の設定をすると、デフォルトで3ソケット1コア1スレッドの設定になってしまうため、windowsでは制限コアしか認識しなくなり、かつ後からトポロジーを変更してもwindowsが正しく認識してくれませんので、インストールからやり直しになります そのため、この時点でトポロジーを手動設定して実CPUと同じに設定しておきましょう 後から「現在の割当」で減らす分には問題ないので、インストール時点ではその環境で使用できる最大CPU数を設定しておくと良いと思います ストレージ今回はvirtioを使用するため、ディスクの設定をデフォルトのSATAから変更します詳細オプションから「SCSI」を選択しますここで「virtio」を選択可能ですが、現在はレガシーな手法とされており、VirtIO SCSIコントローラを使用して制御するのが推奨されています CDROM「ハードウェアを追加」からCDROMドライブをもう一台追加し、先程用意したvirtioドライバのisoを設定します NIC「モデル」から「virtio」を選択しますネットワークソースはNATなりブリッジなりmacvtapなりお好みで ディスプレイandroid-x86の時にも設定しましたが、リッスンタイプを「なし」にして、「GLを開く」をONにして、レンダリングデバイスを設定します。 2019-01現在のvirt-managerのバグで、レンダリングデバイスを指定して「適用」してもデバイスが「自動」に戻ってしまうため、もう一度デバイスを設定して「適用」してください コントローラ「ハードウェアを追加」からVirtIO SCSIコントローラを追加しますここで明示的に追加しないと、libvirtがlsilogicエミュレーションのコントローラを勝手に追加しますのでかならず明示的に追加してください Windowsゲストのインストールここまで設定して「インスール開始」を選べばWindowsインストーラが起動ますので、指示に従ってインストールを開始してください。 VirtIOドライバのロードインストール対象を選ぶ時点で、ストレージをVirtIOにしたので対象ディスクが出てこないはずです ここで「ドライバーの読み込み」から第二CDROMに入れたvirtioドライバーディスクからSCSIコントローラドライバを読み込みます ドライバを読み込めば、設定したディスクが一覧に出てくるはずです この時点でネットワーク、グラフィック(QXL)、メモリバルーンのドライバーもロードしておきましょう あとはインストーラーの指示に従ってインストールを進めていけば大丈夫です インストールが完了したら、ゲストをシャットダウンして、いよいよGVTデバイスの設定に入ります GVTデバイスの設定（第一段階）ここからはvirshを使った作業に入ります。ユーザーからのvirshでは、virt-managerで登録したVMの参照ができないため、ここからはrootシェルでの作業になります1$ sudo -s hostdevの追加virsh list –allで先程登録したVMの名前を確認し、virsh editで設定を開きます123456# virsh list --all Id Name State------------------------ - win10 shut off# virsh edit win10 該当VMのXMLが開いたら、videoタグを検索して、その下あたりに以下のようなタグを挿入します123456&lt;hostdev mode=&apos;subsystem&apos; type=&apos;mdev&apos; managed=&apos;yes&apos; model=&apos;vfio-pci&apos; display=&apos;off&apos;&gt; &lt;source&gt; &lt;address uuid=&apos;ab8c3af8-8366-449d-8489-fe9254e44621&apos;/&gt; &lt;/source&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x09&apos; function=&apos;0x0&apos;/&gt;&lt;/hostdev&gt; uuidはその１で決めたUUIDになります。addressのslotは他のデバイスと競合しない適当な値に設定してください Intelドライバのインストールタグを挿入後に設定を保存し、ゲストを起動してデバイスマネージャを開きますしばらくするとWindowsがドライバを自動検索して追加したGVTデバイスにIntel HDドライバを割り当てますもし自動で当たらない場合は手動でドライバの更新を行ってください GVTデバイスにドライバが当たったらゲストをシャットダウンします GVTデバイスの設定（第二段階）再びvirshに入ります XMLスキーマの変更まず先頭のdomainタグに、XMLスキーマを追加します1&lt;domain type=&apos;kvm&apos;&gt; を1&lt;domain type=&apos;kvm&apos; xmlns:qemu=&apos;http://libvirt.org/schemas/domain/qemu/1.0&apos;&gt; これでXML中にqemuのコマンドラインを直に設定できるようになります 標準VGAの無効化まずvideoタグを検索し、1234&lt;video&gt; &lt;model type=&apos;qxl&apos; ram=&apos;65536&apos; vram=&apos;65536&apos; vgamem=&apos;16384&apos; heads=&apos;1&apos; primary=&apos;yes&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x02&apos; function=&apos;0x0&apos;/&gt;&lt;/video&gt; この部分をQXLからcirrusに変更します1234&lt;video&gt; &lt;model type=&apos;cirrus&apos; vram=&apos;16384&apos; heads=&apos;1&apos; primary=&apos;yes&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x02&apos; function=&apos;0x0&apos;/&gt;&lt;/video&gt; その後XMLの末尾、/deviceタグと/domainタグの間に以下の記述を追加します1234&lt;qemu:commandline&gt; &lt;qemu:arg value=&apos;-set&apos;/&gt; &lt;qemu:arg value=&apos;device.video0.driver=ne2k_pci&apos;/&gt;&lt;/qemu:commandline&gt; これはlibvirtの仕様で、graphicデバイスが設定されていると、必ず一つのビデオデバイスが追加されてしまうため、そのビデオデバイスに間違ったドライバを当てることであえてエラーを起こしてそのデバイスを無効化するというバッドノウハウです。 いずれlibvirtでmodel type=’none’が選択できるようになるかもしれません GVTデバイスの有効化qemu:commandlineタグに以下を追加します12&lt;qemu:arg value=&apos;-set&apos;/&gt;&lt;qemu:arg value=&apos;device.hostdev0.x-igd-opregion=on&apos;/&gt; これはintel IGD固有のオプションで、これを与えることで物理ディスプレイ出力を有効化します GVTデバイスは物理ディスプレイに繋がっていませんが、これをONにすることでqemuのgraphicデバイスに接続可能になります 続いて、hostdevタグの中の1&lt;hostdev mode=&apos;subsystem&apos; type=&apos;mdev&apos; managed=&apos;yes&apos; model=&apos;vfio-pci&apos; display=&apos;off&apos;&gt; のdisplayをonに変更します1&lt;hostdev mode=&apos;subsystem&apos; type=&apos;mdev&apos; managed=&apos;yes&apos; model=&apos;vfio-pci&apos; display=&apos;on&apos;&gt; 設定を保存しゲストを起動すればGVTデバイスをビデオデバイスとしたゲストが起動します 起動後の設定virt-managerからゲストを起動すると、しばらくの間はdevice not readyということで表示されません。 GVTデバイスはBIOS ROMを持たないため、seabiosがフレームバッファを認識できないためです しばらく待って、windowsのIntelドライバがGPUを掴めば表示されます その１で確保したGVT_4デバイスはデフォルト解像度が1920x1200なので1920x1200以下のディスプレイで表示した場合、フルスクリーン表示したとしてもドット潰れが発生するため解像度を少し下げます GVTデバイス自体が非力ですし、1900x1080のディスプレイであれば1366x768あたりが実用的な解像度でしょう テスト末代の住民としてはとりあえずまずこれをということでカスタムオーダーメイド３Dの体験版を起動してみました 画質設定はそれなりに落とす必要はありますがそこそこスムーズに動いています もともとノートPCのIntel HDで動かすのは厳しいタイトルなのでスコアはお察しで むしろ個人的には良くここまで動いてるなという感じです 同マシンの素のWindows環境と比べると大体７割ぐらいのスコアでしょうか 先日steamで購入した「ロロナのアトリエ」も動かしてみました こちらはCOM3D2と比較すると相当軽いタイトルなのもあり、普通に遊べるレベルで動いています このようにそこそこ軽いタイトルならば普通に遊べるレベルです まとめ最近になりやっと実用レベルで使えるようになってきたIntel GVT-g、openSUSE Tumbleweedならば比較的簡単に試すことができますので対応iGPUをお持ちの方はぜひ一度お試しください 付録うちで動いているGVT環境のXMLを参考に貼っておきます123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;domain type=&apos;kvm&apos; id=&apos;3&apos; xmlns:qemu=&apos;http://libvirt.org/schemas/domain/qemu/1.0&apos;&gt; &lt;name&gt;win10-gvt1&lt;/name&gt; &lt;uuid&gt;9a210b7d-094c-4912-b624-600019bade4a&lt;/uuid&gt; &lt;metadata&gt; &lt;libosinfo:libosinfo xmlns:libosinfo=&quot;http://libosinfo.org/xmlns/libvirt/domain/1.0&quot;&gt; &lt;libosinfo:os id=&quot;http://microsoft.com/win/10&quot;/&gt; &lt;/libosinfo:libosinfo&gt; &lt;/metadata&gt; &lt;memory unit=&apos;KiB&apos;&gt;4194304&lt;/memory&gt; &lt;currentMemory unit=&apos;KiB&apos;&gt;4194304&lt;/currentMemory&gt; &lt;vcpu placement=&apos;static&apos;&gt;4&lt;/vcpu&gt; &lt;resource&gt; &lt;partition&gt;/machine&lt;/partition&gt; &lt;/resource&gt; &lt;os&gt; &lt;type arch=&apos;x86_64&apos; machine=&apos;pc-q35-3.1&apos;&gt;hvm&lt;/type&gt; &lt;/os&gt; &lt;features&gt; &lt;acpi/&gt; &lt;apic/&gt; &lt;hyperv&gt; &lt;relaxed state=&apos;on&apos;/&gt; &lt;vapic state=&apos;on&apos;/&gt; &lt;spinlocks state=&apos;on&apos; retries=&apos;8191&apos;/&gt; &lt;/hyperv&gt; &lt;vmport state=&apos;off&apos;/&gt; &lt;/features&gt; &lt;cpu mode=&apos;custom&apos; match=&apos;exact&apos; check=&apos;full&apos;&gt; &lt;model fallback=&apos;forbid&apos;&gt;Skylake-Client-IBRS&lt;/model&gt; &lt;vendor&gt;Intel&lt;/vendor&gt; &lt;topology sockets=&apos;1&apos; cores=&apos;2&apos; threads=&apos;2&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;ss&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;vmx&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;hypervisor&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;tsc_adjust&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;clflushopt&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;umip&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;ssbd&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;xsaves&apos;/&gt; &lt;feature policy=&apos;require&apos; name=&apos;pdpe1gb&apos;/&gt; &lt;feature policy=&apos;disable&apos; name=&apos;hle&apos;/&gt; &lt;feature policy=&apos;disable&apos; name=&apos;rtm&apos;/&gt; &lt;/cpu&gt; &lt;clock offset=&apos;localtime&apos;&gt; &lt;timer name=&apos;rtc&apos; tickpolicy=&apos;catchup&apos;/&gt; &lt;timer name=&apos;pit&apos; tickpolicy=&apos;delay&apos;/&gt; &lt;timer name=&apos;hpet&apos; present=&apos;no&apos;/&gt; &lt;timer name=&apos;hypervclock&apos; present=&apos;yes&apos;/&gt; &lt;/clock&gt; &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt; &lt;on_reboot&gt;restart&lt;/on_reboot&gt; &lt;on_crash&gt;destroy&lt;/on_crash&gt; &lt;pm&gt; &lt;suspend-to-mem enabled=&apos;no&apos;/&gt; &lt;suspend-to-disk enabled=&apos;no&apos;/&gt; &lt;/pm&gt; &lt;devices&gt; &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt; &lt;disk type=&apos;file&apos; device=&apos;disk&apos;&gt; &lt;driver name=&apos;qemu&apos; type=&apos;qcow2&apos;/&gt; &lt;source file=&apos;/var/lib/libvirt/images/win10.qcow2&apos;/&gt; &lt;backingStore/&gt; &lt;target dev=&apos;sda&apos; bus=&apos;scsi&apos;/&gt; &lt;boot order=&apos;1&apos;/&gt; &lt;alias name=&apos;scsi0-0-0-0&apos;/&gt; &lt;address type=&apos;drive&apos; controller=&apos;0&apos; bus=&apos;0&apos; target=&apos;0&apos; unit=&apos;0&apos;/&gt; &lt;/disk&gt; &lt;controller type=&apos;usb&apos; index=&apos;0&apos; model=&apos;qemu-xhci&apos; ports=&apos;15&apos;&gt; &lt;alias name=&apos;usb&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x02&apos; slot=&apos;0x00&apos; function=&apos;0x0&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;sata&apos; index=&apos;0&apos;&gt; &lt;alias name=&apos;ide&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x1f&apos; function=&apos;0x2&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;0&apos; model=&apos;pcie-root&apos;&gt; &lt;alias name=&apos;pcie.0&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;1&apos; model=&apos;pcie-root-port&apos;&gt; &lt;model name=&apos;pcie-root-port&apos;/&gt; &lt;target chassis=&apos;1&apos; port=&apos;0x10&apos;/&gt; &lt;alias name=&apos;pci.1&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x0&apos; multifunction=&apos;on&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;2&apos; model=&apos;pcie-root-port&apos;&gt; &lt;model name=&apos;pcie-root-port&apos;/&gt; &lt;target chassis=&apos;2&apos; port=&apos;0x11&apos;/&gt; &lt;alias name=&apos;pci.2&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x1&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;3&apos; model=&apos;pcie-root-port&apos;&gt; &lt;model name=&apos;pcie-root-port&apos;/&gt; &lt;target chassis=&apos;3&apos; port=&apos;0x12&apos;/&gt; &lt;alias name=&apos;pci.3&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x2&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;4&apos; model=&apos;pcie-root-port&apos;&gt; &lt;model name=&apos;pcie-root-port&apos;/&gt; &lt;target chassis=&apos;4&apos; port=&apos;0x13&apos;/&gt; &lt;alias name=&apos;pci.4&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x3&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;5&apos; model=&apos;pcie-root-port&apos;&gt; &lt;model name=&apos;pcie-root-port&apos;/&gt; &lt;target chassis=&apos;5&apos; port=&apos;0x14&apos;/&gt; &lt;alias name=&apos;pci.5&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x4&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;pci&apos; index=&apos;6&apos; model=&apos;pcie-to-pci-bridge&apos;&gt; &lt;model name=&apos;pcie-pci-bridge&apos;/&gt; &lt;alias name=&apos;pci.6&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x04&apos; slot=&apos;0x00&apos; function=&apos;0x0&apos;/&gt; &lt;/controller&gt; &lt;controller type=&apos;scsi&apos; index=&apos;0&apos; model=&apos;virtio-scsi&apos;&gt; &lt;alias name=&apos;scsi0&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x05&apos; slot=&apos;0x00&apos; function=&apos;0x0&apos;/&gt; &lt;/controller&gt; &lt;interface type=&apos;bridge&apos;&gt; &lt;mac address=&apos;52:54:00:33:76:f0&apos;/&gt; &lt;source bridge=&apos;bridge0&apos;/&gt; &lt;target dev=&apos;vnet0&apos;/&gt; &lt;model type=&apos;virtio&apos;/&gt; &lt;alias name=&apos;net0&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x01&apos; slot=&apos;0x00&apos; function=&apos;0x0&apos;/&gt; &lt;/interface&gt; &lt;serial type=&apos;pty&apos;&gt; &lt;source path=&apos;/dev/pts/2&apos;/&gt; &lt;target type=&apos;isa-serial&apos; port=&apos;0&apos;&gt; &lt;model name=&apos;isa-serial&apos;/&gt; &lt;/target&gt; &lt;alias name=&apos;serial0&apos;/&gt; &lt;/serial&gt; &lt;console type=&apos;pty&apos; tty=&apos;/dev/pts/2&apos;&gt; &lt;source path=&apos;/dev/pts/2&apos;/&gt; &lt;target type=&apos;serial&apos; port=&apos;0&apos;/&gt; &lt;alias name=&apos;serial0&apos;/&gt; &lt;/console&gt; &lt;input type=&apos;tablet&apos; bus=&apos;usb&apos;&gt; &lt;alias name=&apos;input0&apos;/&gt; &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;1&apos;/&gt; &lt;/input&gt; &lt;input type=&apos;mouse&apos; bus=&apos;ps2&apos;&gt; &lt;alias name=&apos;input1&apos;/&gt; &lt;/input&gt; &lt;input type=&apos;keyboard&apos; bus=&apos;ps2&apos;&gt; &lt;alias name=&apos;input2&apos;/&gt; &lt;/input&gt; &lt;graphics type=&apos;spice&apos;&gt; &lt;listen type=&apos;none&apos;/&gt; &lt;image compression=&apos;off&apos;/&gt; &lt;gl enable=&apos;yes&apos; rendernode=&apos;/dev/dri/by-path/pci-0000:00:02.0-render&apos;/&gt; &lt;/graphics&gt; &lt;sound model=&apos;ich9&apos;&gt; &lt;alias name=&apos;sound0&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x1b&apos; function=&apos;0x0&apos;/&gt; &lt;/sound&gt; &lt;video&gt; &lt;model type=&apos;cirrus&apos; vram=&apos;16384&apos; heads=&apos;1&apos; primary=&apos;yes&apos;/&gt; &lt;alias name=&apos;video0&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x01&apos; function=&apos;0x0&apos;/&gt; &lt;/video&gt; &lt;hostdev mode=&apos;subsystem&apos; type=&apos;mdev&apos; managed=&apos;yes&apos; model=&apos;vfio-pci&apos; display=&apos;on&apos;&gt; &lt;source&gt; &lt;address uuid=&apos;ab8c3af8-8366-449d-8489-fe9254e44621&apos;/&gt; &lt;/source&gt; &lt;alias name=&apos;hostdev0&apos;/&gt; &lt;rom bar=&apos;on&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x02&apos; function=&apos;0x0&apos;/&gt; &lt;/hostdev&gt; &lt;redirdev bus=&apos;usb&apos; type=&apos;spicevmc&apos;&gt; &lt;alias name=&apos;redir0&apos;/&gt; &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;2&apos;/&gt; &lt;/redirdev&gt; &lt;redirdev bus=&apos;usb&apos; type=&apos;spicevmc&apos;&gt; &lt;alias name=&apos;redir1&apos;/&gt; &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;3&apos;/&gt; &lt;/redirdev&gt; &lt;memballoon model=&apos;virtio&apos;&gt; &lt;alias name=&apos;balloon0&apos;/&gt; &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x03&apos; slot=&apos;0x00&apos; function=&apos;0x0&apos;/&gt; &lt;/memballoon&gt; &lt;/devices&gt; &lt;qemu:commandline&gt; &lt;qemu:arg value=&apos;-set&apos;/&gt; &lt;qemu:arg value=&apos;device.video0.driver=ne2k_pci&apos;/&gt; &lt;qemu:arg value=&apos;-set&apos;/&gt; &lt;qemu:arg value=&apos;device.hostdev0.x-igd-opregion=on&apos;/&gt; &lt;/qemu:commandline&gt;&lt;/domain&gt;","link":"/2019/01/26/gvtg2/"}],"tags":[{"name":"misc","slug":"misc","link":"/tags/misc/"},{"name":"openSUSE","slug":"openSUSE","link":"/tags/openSUSE/"},{"name":"KVM","slug":"KVM","link":"/tags/KVM/"},{"name":"GVT-g","slug":"GVT-g","link":"/tags/GVT-g/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"仮想化","slug":"仮想化","link":"/tags/仮想化/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"webArena","slug":"webArena","link":"/tags/webArena/"},{"name":"VirGL","slug":"VirGL","link":"/tags/VirGL/"},{"name":"ffmpeg","slug":"ffmpeg","link":"/tags/ffmpeg/"},{"name":"Tips","slug":"Tips","link":"/tags/Tips/"},{"name":"grub2","slug":"grub2","link":"/tags/grub2/"},{"name":"チラ裏","slug":"チラ裏","link":"/tags/チラ裏/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"openSUSE","slug":"Linux/openSUSE","link":"/categories/Linux/openSUSE/"}]}